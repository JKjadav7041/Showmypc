<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PS/2 Cable Connector & Port 3D Model</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            z-index: 10;
        }
        .controls h3 {
            margin-bottom: 10px;
            color: #333;
        }
        .controls button {
            margin: 5px;
            padding: 8px 15px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        .controls button:hover {
            background: #764ba2;
        }
        .info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 12px;
            color: #555;
        }
    </style>
</head>
<body>
    
    <div class="info">
        Drag to rotate | Scroll to zoom
    </div>
    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, cableGroup, portGroup;
        let autoRotate = true;
        let isConnected = false;
        let animating = false;

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);

            // Camera setup
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(6, 4, 8);
            camera.lookAt(0, 0, 0);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 10);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            const pointLight1 = new THREE.PointLight(0xffffff, 0.4);
            pointLight1.position.set(-10, 5, -10);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0xffffff, 0.3);
            pointLight2.position.set(10, -5, 10);
            scene.add(pointLight2);

            // Create components
            createCableConnector();
            createPS2Port();

            // Handle window resize
            window.addEventListener('resize', onWindowResize);

            // Mouse controls for rotation
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };

            renderer.domElement.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            renderer.domElement.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;

                    cableGroup.rotation.y += deltaX * 0.01;
                    cableGroup.rotation.x += deltaY * 0.01;
                    portGroup.rotation.y += deltaX * 0.01;
                    portGroup.rotation.x += deltaY * 0.01;

                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });

            renderer.domElement.addEventListener('mouseup', () => {
                isDragging = false;
            });

            // Mouse wheel for zoom
            renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                camera.position.z += e.deltaY * 0.01;
                camera.position.z = Math.max(3, Math.min(15, camera.position.z));
            });

            // Animation loop
            animate();
        }

        function createCableConnector() {
            cableGroup = new THREE.Group();

            // 1. Main Single Cable Wire (FIXED - now visible!)
            const cableGeometry = new THREE.CylinderGeometry(0.15, 0.15, 8, 32);
            const cableMaterial = new THREE.MeshPhongMaterial({
                color: 0x9055d6,
                shininess: 40
            });
            const cableWire = new THREE.Mesh(cableGeometry, cableMaterial);
            cableWire.rotation.z = Math.PI / 2; // Rotate to horizontal
            cableWire.position.set(-3, 0, 0); // Position it extending from connector
            cableGroup.add(cableWire);

            // 2. Cable strain relief ridges (for realistic look)
            for (let i = 0; i < 10; i++) {
                const ridgeGeometry = new THREE.CylinderGeometry(0.17, 0.17, 0.1, 32);
                const ridgeMaterial = new THREE.MeshPhongMaterial({
                    color: 0x7d45b8,
                    shininess: 30
                });
                const ridge = new THREE.Mesh(ridgeGeometry, ridgeMaterial);
                ridge.rotation.z = Math.PI / 2;
                ridge.position.set(-6 + (i * 0.4), 0, 0);
                cableGroup.add(ridge);
            }

            // 3. Connector housing base (strain relief)
            const housingBaseGeometry = new THREE.CylinderGeometry(0.28, 0.2, 0.8, 32);
            const housingBaseMaterial = new THREE.MeshPhongMaterial({
                color: 0x9055d6,
                shininess: 50
            });
            const housingBase = new THREE.Mesh(housingBaseGeometry, housingBaseMaterial);
            housingBase.rotation.z = Math.PI / 2;
            housingBase.position.set(0.5, 0, 0);
            cableGroup.add(housingBase);

            // 4. Main connector body (cylindrical mini-DIN)
            const connectorBodyGeometry = new THREE.CylinderGeometry(0.45, 0.45, 1.2, 32);
            const connectorBodyMaterial = new THREE.MeshPhongMaterial({
                color: 0x9055d6,
                shininess: 60
            });
            const connectorBody = new THREE.Mesh(connectorBodyGeometry, connectorBodyMaterial);
            connectorBody.rotation.z = Math.PI / 2;
            connectorBody.position.set(1.4, 0, 0);
            cableGroup.add(connectorBody);

            // 5. Metal shield ring
            const shieldGeometry = new THREE.CylinderGeometry(0.48, 0.48, 0.15, 32);
            const shieldMaterial = new THREE.MeshStandardMaterial({
                color: 0xaaaaaa,
                metalness: 0.9,
                roughness: 0.2
            });
            const shield = new THREE.Mesh(shieldGeometry, shieldMaterial);
            shield.rotation.z = Math.PI / 2;
            shield.position.set(1.85, 0, 0);
            cableGroup.add(shield);

            // 6. Metal connector tip
            const tipGeometry = new THREE.CylinderGeometry(0.42, 0.38, 0.5, 32);
            const tipMaterial = new THREE.MeshStandardMaterial({
                color: 0xc0c0c0,
                metalness: 0.95,
                roughness: 0.15
            });
            const tip = new THREE.Mesh(tipGeometry, tipMaterial);
            tip.rotation.z = Math.PI / 2;
            tip.position.set(2.3, 0, 0);
            cableGroup.add(tip);

            // 7. Inner plastic insulator
            const insulatorGeometry = new THREE.CylinderGeometry(0.35, 0.35, 0.4, 32);
            const insulatorMaterial = new THREE.MeshPhongMaterial({
                color: 0x2a2a2a,
                shininess: 20
            });
            const insulator = new THREE.Mesh(insulatorGeometry, insulatorMaterial);
            insulator.rotation.z = Math.PI / 2;
            insulator.position.set(2.4, 0, 0);
            cableGroup.add(insulator);

            // 8. 6 Metal pins in circular pattern
            const pinPositions = [
                { angle: 0, radius: 0.18 },
                { angle: Math.PI / 3, radius: 0.18 },
                { angle: 2 * Math.PI / 3, radius: 0.18 },
                { angle: Math.PI, radius: 0.18 },
                { angle: 4 * Math.PI / 3, radius: 0.18 },
                { angle: 5 * Math.PI / 3, radius: 0.18 }
            ];

            pinPositions.forEach(pos => {
                const pinGeometry = new THREE.CylinderGeometry(0.025, 0.025, 0.35, 16);
                const pinMaterial = new THREE.MeshStandardMaterial({
                    color: 0xffd700,
                    metalness: 1,
                    roughness: 0.1
                });
                const pin = new THREE.Mesh(pinGeometry, pinMaterial);
                pin.rotation.z = Math.PI / 2;
                pin.position.set(2.55, Math.cos(pos.angle) * pos.radius, Math.sin(pos.angle) * pos.radius);
                cableGroup.add(pin);
            });

            // 9. Center alignment guide
            const guidePinGeometry = new THREE.CylinderGeometry(0.04, 0.04, 0.3, 16);
            const guidePinMaterial = new THREE.MeshPhongMaterial({
                color: 0x1a1a1a
            });
            const guidePin = new THREE.Mesh(guidePinGeometry, guidePinMaterial);
            guidePin.rotation.z = Math.PI / 2;
            guidePin.position.set(2.55, 0, 0);
            cableGroup.add(guidePin);

            // Position cable connector
            cableGroup.position.set(-3, 0, 0);
            scene.add(cableGroup);
        }

        function createPS2Port() {
            portGroup = new THREE.Group();

            // 1. Port mounting plate (circuit board)
            const plateGeometry = new THREE.BoxGeometry(2.5, 2, 0.15);
            const plateMaterial = new THREE.MeshPhongMaterial({
                color: 0x2d7a2d,
                shininess: 30
            });
            const plate = new THREE.Mesh(plateGeometry, plateMaterial);
            plate.position.set(0, 0, -0.5);
            portGroup.add(plate);

            // 2. Port housing (outer metal shell)
            const housingGeometry = new THREE.CylinderGeometry(0.52, 0.52, 1.2, 32);
            const housingMaterial = new THREE.MeshStandardMaterial({
                color: 0x888888,
                metalness: 0.8,
                roughness: 0.3
            });
            const housing = new THREE.Mesh(housingGeometry, housingMaterial);
            housing.rotation.z = Math.PI / 2;
            housing.position.set(0.3, 0, 0);
            portGroup.add(housing);

            // 3. Port body (main cylinder)
            const portBodyGeometry = new THREE.CylinderGeometry(0.5, 0.5, 1.5, 32);
            const portBodyMaterial = new THREE.MeshPhongMaterial({
                color: 0x3a3a3a,
                shininess: 40
            });
            const portBody = new THREE.Mesh(portBodyGeometry, portBodyMaterial);
            portBody.rotation.z = Math.PI / 2;
            portBody.position.set(0.3, 0, 0);
            portGroup.add(portBody);

            // 4. Inner socket (dark cavity)
            const socketGeometry = new THREE.CylinderGeometry(0.43, 0.43, 0.8, 32);
            const socketMaterial = new THREE.MeshPhongMaterial({
                color: 0x1a1a1a,
                shininess: 10
            });
            const socket = new THREE.Mesh(socketGeometry, socketMaterial);
            socket.rotation.z = Math.PI / 2;
            socket.position.set(0.8, 0, 0);
            portGroup.add(socket);

            // 5. Female socket holes (6 receptacles)
            const holePositions = [
                { angle: 0, radius: 0.18 },
                { angle: Math.PI / 3, radius: 0.18 },
                { angle: 2 * Math.PI / 3, radius: 0.18 },
                { angle: Math.PI, radius: 0.18 },
                { angle: 4 * Math.PI / 3, radius: 0.18 },
                { angle: 5 * Math.PI / 3, radius: 0.18 }
            ];

            holePositions.forEach(pos => {
                const holeGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.4, 16);
                const holeMaterial = new THREE.MeshPhongMaterial({
                    color: 0x0a0a0a
                });
                const hole = new THREE.Mesh(holeGeometry, holeMaterial);
                hole.rotation.z = Math.PI / 2;
                hole.position.set(0.8, Math.cos(pos.angle) * pos.radius, Math.sin(pos.angle) * pos.radius);
                portGroup.add(hole);

                // Metal contacts inside holes
                const contactGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.15, 12);
                const contactMaterial = new THREE.MeshStandardMaterial({
                    color: 0xffcc00,
                    metalness: 1,
                    roughness: 0.2
                });
                const contact = new THREE.Mesh(contactGeometry, contactMaterial);
                contact.rotation.z = Math.PI / 2;
                contact.position.set(0.7, Math.cos(pos.angle) * pos.radius, Math.sin(pos.angle) * pos.radius);
                portGroup.add(contact);
            });

            // 6. Center guide hole
            const centerHoleGeometry = new THREE.CylinderGeometry(0.045, 0.045, 0.4, 16);
            const centerHoleMaterial = new THREE.MeshPhongMaterial({
                color: 0x0a0a0a
            });
            const centerHole = new THREE.Mesh(centerHoleGeometry, centerHoleMaterial);
            centerHole.rotation.z = Math.PI / 2;
            centerHole.position.set(0.8, 0, 0);
            portGroup.add(centerHole);

            // 7. Mounting screws
            for (let i = -1; i <= 1; i += 2) {
                const screwHeadGeometry = new THREE.CylinderGeometry(0.12, 0.12, 0.1, 16);
                const screwMaterial = new THREE.MeshStandardMaterial({
                    color: 0x4a4a4a,
                    metalness: 0.7,
                    roughness: 0.4
                });
                const screwHead = new THREE.Mesh(screwHeadGeometry, screwMaterial);
                screwHead.position.set(0, i * 0.9, -0.5);
                portGroup.add(screwHead);

                // Screw slot
                const slotGeometry = new THREE.BoxGeometry(0.08, 0.02, 0.05);
                const slotMaterial = new THREE.MeshPhongMaterial({
                    color: 0x2a2a2a
                });
                const slot = new THREE.Mesh(slotGeometry, slotMaterial);
                slot.position.set(0, i * 0.9, -0.45);
                portGroup.add(slot);
            }

            // Position port
            portGroup.position.set(3, 0, 0);
            portGroup.rotation.y = Math.PI;
            scene.add(portGroup);
        }

        function animate() {
            requestAnimationFrame(animate);

            if (autoRotate && !animating) {
                cableGroup.rotation.y += 0.003;
                portGroup.rotation.y += 0.003;
            }

            renderer.render(scene, camera);
        }

        function animateConnection() {
            if (animating) return;
            
            animating = true;
            const startX = cableGroup.position.x;
            const endX = isConnected ? -3 : 0.5;
            const duration = 1500;
            const startTime = Date.now();

            function step() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Ease in-out
                const eased = progress < 0.5
                    ? 2 * progress * progress
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;

                cableGroup.position.x = startX + (endX - startX) * eased;

                if (progress < 1) {
                    requestAnimationFrame(step);
                } else {
                    animating = false;
                    isConnected = !isConnected;
                }
            }

            step();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function resetView() {
            camera.position.set(6, 4, 8);
            camera.lookAt(0, 0, 0);
            cableGroup.rotation.set(0, 0, 0);
            portGroup.rotation.set(0, Math.PI, 0);
            cableGroup.position.set(-3, 0, 0);
            portGroup.position.set(3, 0, 0);
            isConnected = false;
        }

        function toggleRotation() {
            autoRotate = !autoRotate;
        }

        init();
    </script>
</body>
</html>
